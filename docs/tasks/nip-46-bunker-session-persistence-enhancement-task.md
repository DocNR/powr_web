# NIP-46 Bunker Session Persistence Enhancement Task

## Objective
Enhance the existing NIP-46 bunker authentication system in POWR Workout PWA to solve session persistence issues, ensuring users stay logged in across app sessions using a pragmatic approach that starts with the simplest fix first.

## Current Implementation Analysis

After analyzing `src/lib/auth/hooks.ts` and `src/lib/auth/types.ts`, the current NIP-46 authentication has working connection logic but **session persistence is broken** due to a simple oversight in auto-login:

### **The Core Problem: Auto-Login Ignores Stored Local Signer**

**Root Cause Identified**: The current implementation correctly stores the local signer private key as `secret` in the Account object, but the auto-login process completely ignores this stored key and generates a new one every time.

```typescript
// Current useNip46Login() - CORRECTLY stores local signer key
secret: localSigner.privateKey, // ✅ Stored correctly

// Current useAutoLogin() - INCORRECTLY ignores stored key
const result = await nip46Login(storedAccount.bunker); // ❌ Creates NEW signer instead of using stored one
```

**What happens during auto-login:**
1. `useAutoLogin()` calls `nip46Login(storedAccount.bunker)`
2. `nip46Login()` creates a **new local signer** with `NDKPrivateKeySigner.generate()`
3. Bunker sees this as a **completely new client connection**
4. Bunker requires **re-authorization** because it doesn't recognize the new client
5. User has to approve the connection again every session

### **The Simple Fix: Use Stored Local Signer Key**
The solution is to modify auto-login to use the stored local signer key instead of generating a new one:

```typescript
// Current (broken): Creates new local signer every time
const localSigner = NDKPrivateKeySigner.generate();

// Fixed (working): Use stored local signer to preserve client identity
const localSigner = new NDKPrivateKeySigner(storedAccount.secret);
```

## How This Differs from Current Approach

### **Current NIP-46 Implementation Status**
We already have a working NIP-46 implementation with:
- ✅ **Connection Logic**: Successfully connects to bunkers and handles auth flows
- ✅ **Storage Logic**: Correctly stores bunker URL, local signer key, and relay info
- ✅ **Authentication Flow**: Users can log in with bunkers like nsec.app
- ❌ **Session Persistence**: Auto-login creates new client identity each time

### **The One-Line Fix Needed**
The difference between broken and working session persistence is literally one line of code in `useAutoLogin()`:

```typescript
// BEFORE (broken):
const result = await nip46Login(storedAccount.bunker); // Generates new local signer

// AFTER (working):
const localSigner = new NDKPrivateKeySigner(storedAccount.secret);
// ... then use this localSigner to create the NIP-46 signer
```

### **Why This Should Work**
1. **We already store the local signer key** in `storedAccount.secret`
2. **Bunkers authorize specific client keypairs** - not just any client
3. **Using the same local signer key** = same client identity = no re-authorization needed
4. **All other connection logic remains the same** - just restore instead of generate

## NIP-46 Security Architecture (CRITICAL UNDERSTANDING)

### Two Different Private Keys in NIP-46:

#### 1. **User's Real Private Key** (Remote/Secure)
- **Location**: Stored securely on the bunker server (nsec.app, nsecBunker, etc.)
- **Purpose**: The user's actual Nostr identity and signing key
- **Security**: **NEVER exposed to our web app** - stays on the bunker
- **Usage**: Signs actual Nostr events through the bunker

#### 2. **Local Signer Private Key** (Client/Temporary)
- **Location**: Generated by our app for this specific bunker connection
- **Purpose**: Authenticates our app as a trusted client to the bunker
- **Security**: **Safe to store locally** - it's just for client identification
- **Usage**: Encrypts communication between our app and the bunker

### Why This is Secure:
The local signer key doesn't give access to the user's Nostr identity - it just proves we're the same app the user previously authorized. The user's real private key never leaves the bunker.

### The Session Persistence Problem:
Each time we create a new local signer, the bunker sees us as a completely different client and requires re-authorization. By using the stored local signer private key, we can recreate the exact same client identity that the bunker already trusts.

## Implementation Steps

### **Phase 0: Quick Win (30 minutes) - RECOMMENDED START**
Following `.clinerules/simple-solutions-first.md`, test the minimal fix first:

- [ ] **Validate Current Storage**
  ```typescript
  // Check if we have the required data for simple fix
  const hasRequiredData = storedAccount.secret && 
                         storedAccount.bunker && 
                         storedAccount.relays;
  console.log('Has required data for simple fix:', hasRequiredData);
  console.log('NDK version:', require('@nostr-dev-kit/ndk/package.json').version);
  ```

- [ ] **Verify NDK Serialization Methods Exist**
  ```typescript
  // Test if these methods exist in NDK v2.14.30
  console.log('toPayload exists:', typeof signer.toPayload === 'function');
  console.log('fromPayload exists:', typeof NDKNip46Signer.fromPayload === 'function');
  ```

- [ ] **Implement Simple Fix in useAutoLogin() with Error Handling**
  ```typescript
  // Replace this broken pattern:
  const result = await nip46Login(storedAccount.bunker); // Creates new signer
  
  // With this enhanced simple fix:
  if (storedAccount.secret && storedAccount.bunker && storedAccount.relays) {
    try {
      console.log('[Auto Login] Attempting simple local signer restoration...');
      
      const ndk = await getNDK();
      
      // Use stored local signer key instead of generating new one
      const localSigner = new NDKPrivateKeySigner(storedAccount.secret);
      const bunkerNDK = new NDK({ 
        explicitRelayUrls: storedAccount.relays, 
        signer: localSigner 
      });
      
      // Add timeout for connection
      await Promise.race([
        bunkerNDK.connect(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 10000))
      ]);
      
      const signer = new NDKNip46Signer(bunkerNDK, storedAccount.bunker, localSigner);
      
      // Add timeout to prevent hanging
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Signer connection timeout')), 15000)
      );
      
      await Promise.race([
        signer.blockUntilReady(),
        timeoutPromise
      ]);
      
      ndk.signer = signer;
      console.log('[Auto Login] Simple fix successful - session restored!');
      return true;
      
    } catch (error) {
      console.warn('[Auto Login] Simple fix failed:', error);
      // Clear potentially invalid stored data
      setAccounts(accounts.filter(a => a.pubkey !== storedAccount.pubkey));
      setLoginMethod(null);
      return false;
    }
  }
  ```

- [ ] **Test Session Persistence**
  - Login with NIP-46 bunker
  - Refresh page/restart app
  - Verify auto-login works without re-authorization
  - **If this works, you may not need the complex hybrid approach!**

- [ ] **Add Decision Tree Logic**
  ```typescript
  // Decision tree after Phase 0 testing:
  if (simpleFixWorks) {
    // SUCCESS: Document the simple solution and stop here
    console.log('✅ Phase 0 simple fix solved session persistence!');
    // ✅ Auto-login works without re-authorization
    // ✅ User stays logged in across app restarts
    // ✅ Connection established within 15 seconds
    // ✅ No user interaction required
    // Update task status: COMPLETE with simple solution
    // No need for complex hybrid approach
  } else {
    // FALLBACK: Proceed to Phase 1 hybrid approach
    console.log('⚠️ Phase 0 failed, proceeding to hybrid approach...');
    // Document what specifically failed for Phase 1 planning
    console.log('Failure reason:', specificError);
    // Continue with NDK serialization + fallback strategy
  }
  ```

### **Phase 1: Hybrid Approach (Only if Phase 0 fails)**

#### **Add URL Patch (If Needed)**
Implement Stacker News URL patch if bunker:// parsing issues occur:

- [ ] **Implement NDKNip46SignerURLPatch**
  ```typescript
  // Based on verified Stacker News workaround for NDK URL parsing
  class NDKNip46SignerURLPatch extends NDKNip46Signer {
    connectionTokenInit(connectionToken: string) {
      // Fix bunker:// URL parsing issue - replace bunker:// with http://
      connectionToken = connectionToken.replace('bunker://', 'http://');
      return super.connectionTokenInit(connectionToken);
    }
  }
  ```

#### **Enhanced Account Type for Dual Storage**
- [ ] **Add Hybrid Storage Fields**
  ```typescript
  export interface Account {
    // ... existing fields ...
    
    // PRIMARY: NDK official serialization
    signerPayload?: string; // Complete serialized NDKNip46Signer state
    
    // FALLBACK: Manual recreation data
    localSignerKey?: string; // Encrypted local signer private key
    bunkerUrl?: string; // Clean bunker URL for recreation
    
    // Connection metadata
    connectionToken?: string; // Full bunker connection token
    lastConnected?: number; // Timestamp of last successful connection
    restorationMethod?: 'simple' | 'payload' | 'localKey' | 'failed'; // Track which method worked
  }
  ```

#### **Hybrid Restoration Logic**
- [ ] **Implement Dual Restoration Strategy**
  - PRIMARY: Try NDK `fromPayload()` restoration first
  - FALLBACK: Use local signer key + bunker URL recreation
  - Handle restoration failures gracefully with clear error messages
  - Validate restored signer connection before proceeding

### **Phase 2: Enhanced Features (Only if needed)**

#### **Connection Health Monitoring**
- [ ] **Add Connection Status Tracking**
  - Track bunker connection health in auth state
  - Show connection status in UI (connected/connecting/failed)
  - Provide reconnection options when connection drops

#### **Security Enhancements**
- [ ] **Secure Local Signer Storage**
  - Encrypt local signer private keys before localStorage storage
  - Use Web Crypto API for encryption/decryption
  - Implement secure key derivation for encryption

## Research Findings from Stacker News

### Key Patterns Discovered:
1. **NDKNip46SignerURLPatch**: Stacker News uses a patched version to fix URL parsing issues
2. **Local Signer Storage**: They store the local signer private key in localStorage for persistence
3. **Challenge Resolver**: Proper handling of auth URL popups for remote signer challenges
4. **Connection State Management**: Separate NDK instances for bunker communication
5. **Timeout Handling**: Proper timeouts for connection establishment

### Critical Implementation Details:

#### **NDK Official Serialization (NEEDS VERIFICATION)**
```typescript
// NDK's built-in serialization support (CLAIMED - needs verification in v2.14.30)
// File: ndk-core/src/signers/nip46/index.ts, Lines 337-363
const payload = signer.toPayload(); // Serialize complete signer state
localStorage.setItem('nip46-signer-payload', payload);

// Restore from payload
const signer = await NDKNip46Signer.fromPayload(payload, ndk);
```

**⚠️ VERIFICATION REQUIRED**: These methods need verification in our actual NDK version (v2.14.30). The Phase 0 quick win should test method existence before relying on them.

#### **Local Signer Key Approach (SIMPLE BACKUP)**
```typescript
// Simpler approach - store just the local signer private key
// Use when NDK serialization fails or for debugging
localStorage.setItem('nip46-local-key', signer.localSigner.privateKey);

// Recreate signer with stored local key
const signer = new NDKNip46Signer(ndk, bunkerUrl, storedLocalKey);
```

## Success Criteria

### **Phase 0 Success Criteria (Minimum Viable Fix)**
- [ ] Auto-login uses stored local signer key instead of generating new one
- [ ] NIP-46 bunker sessions persist across app reloads without re-authorization
- [ ] Connection timeout handling prevents hanging on failed connections
- [ ] Clear error messages when restoration fails
- [ ] Fallback to manual login when auto-login fails

### **Enhanced Success Criteria (If Phase 1+ needed)**
- [ ] Hybrid restoration works with both NDK serialization and local key fallback
- [ ] Connection status visible in UI (connected/connecting/failed)
- [ ] Local signer keys encrypted before browser storage
- [ ] Session cleanup properly removes stored credentials on logout
- [ ] No breaking changes to existing authentication methods

### **User Experience Goals**
- [ ] Loading indicators show during connection restoration
- [ ] Users can cancel long connection attempts
- [ ] Clear error messages guide users through troubleshooting
- [ ] Seamless auto-login experience across app sessions

## Timeline

### **Simplified Approach (Following simple-solutions-first.md)**
- **Phase 0**: Quick Win - Simple fix (30 minutes)
  - Test using stored local signer key instead of generating new one
  - Add basic error handling and timeout logic
  - **If successful**: Task complete, no further phases needed!

### **Fallback Approach (Only if Phase 0 fails)**
- **Phase 1**: Hybrid persistence strategy (1-2 days)
- **Phase 2**: Enhanced features and security (1-2 days)

**Optimistic Timeline**: 30 minutes (if simple fix works)
**Pessimistic Timeline**: 3-4 days (if complex hybrid approach needed)

**Expected Outcome**: Based on analysis, the simple fix should resolve the core issue since we're already storing the local signer key correctly - we just need to use it instead of generating a new one.

## Technical Implementation Details

### **Phase 0: Simple Fix Implementation**
```typescript
// Current broken auto-login in useAutoLogin():
if (loginMethod === 'nip46' && storedAccount.bunker) {
  const result = await nip46Login(storedAccount.bunker); // ❌ Creates new signer
  return result.success;
}

// Enhanced simple fix:
if (loginMethod === 'nip46' && storedAccount.bunker && storedAccount.secret && storedAccount.relays) {
  try {
    console.log('[Auto Login] Attempting simple local signer restoration...');
    
    const ndk = await getNDK();
    
    // Use stored local signer key instead of generating new one
    const localSigner = new NDKPrivateKeySigner(storedAccount.secret);
    const bunkerNDK = new NDK({ 
      explicitRelayUrls: storedAccount.relays, 
      signer: localSigner 
    });
    
    // Add timeout for bunker NDK connection
    await Promise.race([
      bunkerNDK.connect(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('Bunker NDK connection timeout')), 10000))
    ]);
    
    const signer = new NDKNip46Signer(bunkerNDK, storedAccount.bunker, localSigner);
    
    // Add timeout to prevent hanging on signer ready
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Signer connection timeout')), 15000)
    );
    
    await Promise.race([
      signer.blockUntilReady(),
      timeoutPromise
    ]);
    
    ndk.signer = signer;
    console.log('[Auto Login] Simple fix successful - session restored!');
    return true;
    
  } catch (error) {
    console.warn('[Auto Login] Simple fix failed:', error);
    // Clear potentially invalid stored data
    setAccounts(accounts.filter(a => a.pubkey !== storedAccount.pubkey));
    setLoginMethod(null);
    return false;
  }
}
```

### **Decision Tree After Phase 0**
```typescript
// After implementing and testing Phase 0:
if (simpleFixWorks) {
  // SUCCESS: Document the simple solution and stop here
  console.log('✅ Phase 0 simple fix solved session persistence!');
  // Update task status: COMPLETE with simple solution
  // No need for complex hybrid approach
  // Total implementation time: ~30 minutes
} else {
  // FALLBACK: Proceed to Phase 1 hybrid approach
  console.log('⚠️ Phase 0 failed, proceeding to hybrid approach...');
  // Continue with NDK serialization + fallback strategy
  // Estimated additional time: 3-4 days
}
```

## Enhanced Account Type (Phase 1+ Only)

### **If Phase 0 Fails: Enhanced Account Interface**
```typescript
// Enhanced Account interface with dual storage strategy (only if simple fix fails)
export interface Account {
  method: LoginMethod;
  pubkey: string;
  npub?: string;
  name?: string;
  picture?: string;
  
  // Current NIP-46 fields (keep these)
  bunker?: string; // Original bunker URL
  secret?: string; // Local signer private key (Phase 0 uses this)
  relays?: string[];
  
  // Enhanced fields (only add if Phase 0 fails)
  signerPayload?: string; // Complete serialized NDKNip46Signer state
  localSignerKey?: string; // Encrypted local signer private key
  bunkerUrl?: string; // Clean bunker URL for recreation
  connectionToken?: string; // Full bunker connection token
  lastConnected?: number; // Timestamp of last successful connection
  restorationMethod?: 'simple' | 'payload' | 'localKey' | 'failed'; // Track which method worked
}
```

## Stacker News URL Patch (If Needed)

### **NDKNip46SignerURLPatch Implementation**
```typescript
// Based on verified Stacker News workaround for NDK URL parsing
// File: /Users/danielwyler/ReferenceRepos/research/stacker.news/lib/nostr.js
class NDKNip46SignerURLPatch extends NDKNip46Signer {
  connectionTokenInit(connectionToken: string) {
    // Fix bunker:// URL parsing issue - replace bunker:// with http://
    connectionToken = connectionToken.replace('bunker://', 'http://');
    return super.connectionTokenInit(connectionToken);
  }
}

// Use patched version if URL parsing issues occur
const signer = new NDKNip46SignerURLPatch(
  bunkerNDK,
  remoteSignerURL,
  localSigner,
);
```

## Security Utilities (Phase 1+ Only)

### **Secure Storage (Only if enhanced approach needed)**
```typescript
// Encrypt sensitive data before localStorage storage
async function encryptLocalSignerKey(privateKey: string): Promise<string> {
  const key = await crypto.subtle.generateKey(
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(privateKey);
  
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    encoded
  );
  
  return JSON.stringify({
    encrypted: Array.from(new Uint8Array(encrypted)),
    iv: Array.from(iv),
    keyData: await crypto.subtle.exportKey('raw', key)
  });
}

async function decryptLocalSignerKey(encryptedData: string): Promise<string> {
  const { encrypted, iv, keyData } = JSON.parse(encryptedData);
  
  const key = await crypto.subtle.importKey(
    'raw',
    new Uint8Array(keyData),
    { name: 'AES-GCM' },
    false,
    ['decrypt']
  );
  
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: new Uint8Array(iv) },
    key,
    new Uint8Array(encrypted)
  );
  
  return new TextDecoder().decode(decrypted);
}
```

## References

### Research Findings Summary

#### **NDK Official API (NEEDS VERIFICATION)**
- **File**: `ndk-core/src/signers/nip46/index.ts`, Lines 337-363
- **Methods**: `toPayload()` and `static fromPayload(payloadString, ndk)`
- **Functionality**: Complete signer state serialization including connection details and local signer
- **Status**: Needs verification in our NDK version (v2.14.30)

#### **Stacker News Patterns (VERIFIED)**
- **File**: `/Users/danielwyler/ReferenceRepos/research/stacker.news/lib/nostr.js`
  - ✅ **NDKNip46SignerURLPatch**: URL parsing fix for bunker:// URLs
  - ✅ **Challenge Resolver**: Auth URL popup handling in nostr-auth.js
  - ✅ **Connection Management**: Separate NDK instances for bunker communication

### Related .clinerules
- `.clinerules/web-private-key-security.md` - Security requirements for browser storage
- `.clinerules/ndk-best-practices.md` - NDK singleton and authentication patterns
- `.clinerules/simple-solutions-first.md` - Start with simplest solution first

### Key Files to Modify
- `src/lib/auth/hooks.ts` - Modify useAutoLogin() to use stored local signer key
- `src/lib/auth/types.ts` - Potentially enhance Account type if Phase 1+ needed
- `src/lib/auth/atoms.ts` - Potentially add connection status atoms if enhanced features needed

## Implementation Strategy

**SIMPLE FIX FIRST**: Our current authentication system is well-architected. The session persistence issue appears to be a simple oversight where auto-login doesn't use the stored local signer key.

**Key Changes Needed**:
1. **Phase 0**: Modify auto-login to use stored local signer key instead of generating new one
2. **If Phase 0 works**: Task complete! Document the simple solution.
3. **If Phase 0 fails**: Proceed to hybrid approach with NDK serialization and enhanced features.

**This approach transforms the task from:**
- **Before**: "Implement complex hybrid approach" (4-5 days)
- **After**: "Try simple fix first, fall back to complex approach if needed" (30 minutes to 4 days)

This could potentially reduce implementation time from 4-5 days to 30 minutes if the simple fix works!

---

**Last Updated**: 2025-08-15  
**Project**: POWR Workout PWA  
**Environment**: Web Browser  
**Research Source**: Stacker News + NDK Documentation  
**Strategy**: Simple solutions first, complex fallback if needed